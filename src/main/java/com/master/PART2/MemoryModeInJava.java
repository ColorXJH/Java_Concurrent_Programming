package com.master.PART2;

/**
 * @author ColorXJH
 * @version 1.0
 * @description: java内存模型
 * @date 2024-03-05 15:13
 */
public class MemoryModeInJava {
}

final class SetCheck{
    private int a=0;
    private int b=0;
    void set(){
        a=1;
        b=-1;
    }
    //在串行化语言里 该方法永远不会返回false,即使编译器，运行系统及硬件可以用任何掉哟给代码，情况还是如此
    boolean check(){
        return ((b==0)||(b==-1&&a==1));
    }
    //以下为可能执行的路线
        //编译器可以重新安排语句的执行顺序，这样b就可以在a前面赋值，如果方法是内嵌的，方法还可以把其他语句重新排列
        //处理器可以改变这些语句的机器指令的执行顺序，甚至同时执行这些语句
        //存储系统（由于被缓存控制单元控制）也可以重新安排对应存储单元的写操作顺序，这些写操作可能和其他计算和存储操作同时发生
        //编译器、处理器和/或存储系统都可以把这两条语句的机器指令交叉执行，例如在一台32位机器上，可能先写b的高位，然后再写a,最后写b的低位
        //编译器、处理器和/或存储系统都可以使对应于变量的存储单元一直保留着原来的值，以某种方式维护者相应的值
            //(例如再cpu的寄存器中)，以保证代码正常运行，直到一个check调用才更新
            //通过管道超标量cpu,多层缓存，装载/存储平衡，和过程间寄存器分配策略等等，计算机执行速度都得到了迅速发展

    //java的编程模型围绕着以下三个相关的问题
        //

}