package com.master.PART2;

/**
 * @author ColorXJH
 * @version 1.0
 * @description: 同步机制
 * 使用锁可以避免底层的存储冲突和相应的高层面上的不变约束冲突
 * @date 2024-02-22 8:43
 */
public class Even {
    private int n=0;
    private volatile int num;
    private volatile Integer count;
    private volatile int[] muns;

    public int next(){
        ++n;
        ++n;
        return n;
    }
    //将next方法声明为synchronized可以避免冲突的执行路线

    public void test(){
        //同步块需要一个参数来表明锁住的是哪个对象
        synchronized (this){
            //锁的申请和释放是在使用synchronized关键字时根据内部的申请释放协议来使用的
            //所有的锁都是块结构，当进入synchronized方法或者块的时候得到锁，退出的时候释放锁
            //即使因异常退出也会释放锁，不会有忘了释放锁的情况发生
            //锁操作基于“每线程”而不是“每调用”
            //非同步的方法在任何时候都可以执行，即使同步方法正在执行，换句话说，synchronized和原子操作不是等价的，但是同步可以实现原子操作
        }
    }
    //子类和父类方法使用同一个锁（在 Java 中，同步方法的锁是该方法所属对象的实例。），但是内部类的锁和他的外部类无关，一个非静态的内部类可以锁住他的外部类
    public synchronized void test2(){
        //静态：锁住一个对象并不代表不可以访问这个对象或者其任何父类对象的静态数据，可以通过synchronized static方法或者块来实现静态数据的保护
        //静态同步方法使用该静态方法所在的类相关的Class对象拥有的锁，比如C类的静态锁：C.class
        //和每个类相关的静态锁与任何其他的类的锁都没有关系，包括他的父类
        //如果想在子类中增加一个静态同步方法来达到保护父类的静态数据的目的时不可能的，应该用明确的块版本，用下面这种方式也不好
            //synchronized(getClass()){body}
            //这里实际锁住的类（或子类）和声明了需要保护的静态数据的类可能根本不同
    }

    //对象和锁
        //每个Object类型及其子类的实例都拥有一把锁，，而int及float等基本类行都不是Object类
        //基本类型只能通过包含他们的对象被锁住
        //每一个单独的成员变量都不能标记为synchronized
        //锁只能在使用成员变量的方法中应用
        //将成员变量声明为volatile类型，这将影响成员变量的原子性，可见性和顺序性
        //包含基本类型的数组对象也是拥有锁的对象，但是他的每个基本元素却没有锁，不能把数组元素声明为volatile
        //锁住Object类型的数组，不会自动的锁住数组中的每个元素，没有在一个原子操作中同时锁住多个对象的构建
        //Class的实例是Object,Class对象相关的锁可以用在以static synchronized声明的方法中

    //synchronized 关键字确实可以确保多线程之间对变量的操作是同步的，但它主要确保了多线程之间的同步访问，而不涉及内存与 CPU 缓存之间的同步问题。
    //在多核计算机中，每个 CPU 核心都有自己的缓存，它们可能会在本地缓存中保存变量的副本，而不是直接访问主内存。这就可能导致多个线程在不同的 CPU 核心上访问到不同的变量副本，从而引发数据不一致的问题。
    //为了解决这个问题，Java 中的 synchronized 关键字会通过锁机制来确保同一时间只有一个线程可以进入同步代码块或方法，从而避免了多线程同时访问导致的数据竞争问题。当一个线程获取到锁时，它会将本地缓存中的数据同步到主内存中，并且其他线程会看到更新后的值。这样就保证了多线程之间对变量的操作是同步的。
    //因此，虽然 synchronized 关键字没有直接涉及内存与 CPU 缓存之间的同步，但通过锁机制，它确保了多线程之间对变量的操作是同步的，从而避免了数据不一致的问题。

    //当一个线程获取到 synchronized 锁时，它会将本地缓存中的数据同步到主内存中，
    //这确保了其他线程在获取锁时能够看到更新后的值。这与 volatile 的内存语义相似，
    //即对一个 volatile 变量的写操作会立即被其他线程可见。

    //但是，synchronized 和 volatile 在实现方式和适用场景上有所不同：
        //synchronized 是一种重量级锁，它可以用来实现临界区同步，保证了代码块的原子性和内存可见性，但是会带来一定的性能开销。
        //volatile 关键字适用于一种更轻量级的同步机制，它主要用于保证变量的可见性，但并不保证原子性。volatile 适用于单个变量的读写操作，并不适用于复合操作，如 count++ 这样的操作。
        //因此，虽然 synchronized 和 volatile 都可以保证内存的可见性，但是它们在功能和使用上有所区别，需要根据具体的场景和需求进行选择。
}
